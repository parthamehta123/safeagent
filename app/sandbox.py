import os
import time

from app.snapshot import clone_repo, hash_files
from app.patcher import apply_patch
from app.verifier import run_ast_checks, run_tests
from app.policy import enforce_policy, validate_diff_safety
from app.audit import write_audit_log
from app.github_pr import GitHubPRClient
from app.llm import repair_plan, repair_full_file
from app.db import SessionLocal, AgentSession

MAX_PATCH_ATTEMPTS = 3


def execute_plan(repo_url: str, plan, prompt: str | None = None):
    start = time.time()
    trace = {}
    db = SessionLocal()

    session_row = AgentSession(
        repo_url=repo_url,
        prompt=prompt or "",
        files_changed=[e.file_path for e in plan.edits],
        plan=plan.model_dump(),
        status="started",
    )

    db.add(session_row)
    db.commit()

    try:
        # 1. Clone repo into isolated workspace
        t0 = time.time()
        repo = clone_repo(repo_url)
        trace["clone_ms"] = round((time.time() - t0) * 1000, 2)

        # 2. Hash real files (ground truth)
        t1 = time.time()
        manifest = hash_files(repo)
        trace["hash_ms"] = round((time.time() - t1) * 1000, 2)

        # 3. Attempt patch with self-repair loop
        t2 = time.time()
        repair_attempts = 0

        for attempt in range(MAX_PATCH_ATTEMPTS):
            try:
                # Always re-enforce policy before every attempt
                enforce_policy(plan.edits)

                for edit in plan.edits:
                    validate_diff_safety(edit.unified_diff)

                    if manifest.get(edit.file_path) != edit.original_hash:
                        raise RuntimeError(f"Hash mismatch for {edit.file_path}")

                    apply_patch(repo, edit.unified_diff)

                # If patch applied cleanly, exit retry loop
                break

            except Exception as patch_error:
                repair_attempts += 1

                if attempt == MAX_PATCH_ATTEMPTS - 1:
                    # FINAL FALLBACK: full rewrite instead of diff
                    for edit in plan.edits:
                        path = os.path.join(repo, edit.file_path)

                        with open(path, "r", encoding="utf-8") as f:
                            original = f.read()

                        # Ask model for full rewrite instead of diff
                        new_content = repair_full_file(
                            prompt=prompt or "",
                            file_path=edit.file_path,
                            content=original,
                        )

                        with open(path, "w", encoding="utf-8") as f:
                            f.write(new_content)

                    break  # exit retry loop and continue to verification

                # Gather file contents for repair
                files = {}
                for edit in plan.edits:
                    full_path = os.path.join(repo, edit.file_path)
                    with open(full_path, "r", encoding="utf-8") as f:
                        files[edit.file_path] = f.read()

                # Ask model to repair the plan
                plan = repair_plan(
                    prompt=prompt or "",
                    files=files,
                    manifest=manifest,
                    failed_diff=edit.unified_diff,
                    error=str(patch_error),
                )

        trace["patch_ms"] = round((time.time() - t2) * 1000, 2)
        trace["repair_attempts"] = repair_attempts

        # 4. Deterministic verification
        t3 = time.time()
        run_ast_checks(repo)
        run_tests(repo)
        trace["verification_ms"] = round((time.time() - t3) * 1000, 2)

        # Store final diff for observability/debugging
        session_row.diff = "\n\n".join(
            [e.unified_diff for e in plan.edits if e.unified_diff]
        )

        # Store trace
        session_row.trace = trace

        # 5. Attempt PR creation (safe fallback for local dev)
        pr_url = None
        branch = None

        try:
            client = GitHubPRClient()
            branch = f"safeagent-{int(time.time())}"
            client.create_branch(branch)

            for edit in plan.edits:
                full_path = os.path.join(repo, edit.file_path)

                with open(full_path, "r", encoding="utf-8") as f:
                    content = f.read()

                client.commit_file(
                    branch=branch,
                    file_path=edit.file_path,
                    new_content=content,
                    message=f"SafeAgent update: {edit.file_path}",
                )

            pr_url = client.open_pull_request(
                branch=branch,
                title="SafeAgent Proposed Changes",
                body=(
                    "This PR was generated by SafeAgent after:\n"
                    "- hash verification\n"
                    "- policy enforcement\n"
                    "- diff safety validation\n"
                    "- AST checks\n"
                    "- optional test validation"
                ),
            )

            client.comment_on_pr(
                pr_url,
                body=(
                    "ðŸ¤– SafeAgent applied this change after:\n"
                    "- Hash verification\n"
                    "- Policy enforcement\n"
                    "- Diff safety validation\n"
                    "- AST checks\n"
                    "- Optional test execution\n\n"
                    "This PR was generated autonomously."
                ),
            )

        except Exception:
            pr_url = "(skipped: GitHub not configured)"

        # 6. Audit log
        write_audit_log(
            {
                "repo": repo_url,
                "files": [e.file_path for e in plan.edits],
                "branch": branch,
                "pull_request": pr_url,
                "status": "success",
                "duration_sec": round(time.time() - start, 2),
                "trace": trace,
            }
        )

        # 7. Persist success
        session_row.status = "success"
        session_row.result = {
            "branch": branch,
            "pr": pr_url,
        }
        session_row.duration_sec = round(time.time() - start, 2)
        db.commit()

        return pr_url

    except Exception as e:
        session_row.status = "failed"
        session_row.error = str(e)
        session_row.duration_sec = round(time.time() - start, 2)
        db.commit()

        return {
            "status": "failed",
            "error": str(e),
        }

    finally:
        db.close()
